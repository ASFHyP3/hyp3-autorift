--- testautoRIFT_ISCE.orig.py	2020-06-26 08:52:27.311909308 -0800
+++ testautoRIFT_ISCE.py	2020-06-26 09:39:41.777619916 -0800
@@ -1,6 +1,12 @@
 #!/usr/bin/env python3
 
-#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+# This is a substantially modified copy of the testautoRIFT_ISCE.py script
+# provided in the autoRIFT v1.0.4 release, See the LICENSE file in this directory
+# for the original terms and conditions, and CHANGES.diff for a detailed
+# description of the changes. Notice, all changes are released under the terms
+# and conditions of hyp3-autorift's LICENSE.
+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 # Copyright 2019 California Institute of Technology. ALL RIGHTS RESERVED.
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
@@ -26,18 +32,24 @@
 #
 # Author: Yang Lei
 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+import argparse
+import logging
+import subprocess
+import time
+from datetime import date
+
+import cv2
+import numpy as np
+import scipy.io as sio
+from isce.components.contrib.geo_autoRIFT.autoRIFT import autoRIFT_ISCE
+from isce.components.isceobj.Util.ImageUtil import ImageLib as IML
+from osgeo import gdal
 
-
-
-
-import pdb
-from osgeo import gdal, osr
-
+from hyp3_autorift import netcdf_output as no
 
 
 
 def runCmd(cmd):
-    import subprocess
     out = subprocess.getoutput(cmd)
     return out
 
@@ -48,7 +60,6 @@
     '''
     Command line parser.
     '''
-    import argparse
 
     parser = argparse.ArgumentParser(description='Output geo grid')
     parser.add_argument('-m', '--input_m', dest='indir_m', type=str, required=True,
@@ -86,9 +97,6 @@
     '''
     Load the product using Product Manager.
     '''
-    import isce
-    import logging
-    from imageMath import IML
     
     IMG = IML.mmapFromISCE(filename, logging)
     img = IMG.bands[0]
@@ -97,7 +105,6 @@
 
 
 def loadProductOptical(filename):
-    import numpy as np
     '''
     Load the product using Product Manager.
     '''
@@ -121,12 +128,6 @@
     Wire and run geogrid.
     '''
 
-    import isce
-    from components.contrib.geo_autoRIFT.autoRIFT import autoRIFT_ISCE
-    import numpy as np
-    import isceobj
-    import time
-    import subprocess
     
     
     obj = autoRIFT_ISCE()
@@ -336,7 +337,6 @@
     print("AutoRIFT Done!!!")
     print(time.time()-t1)
 
-    import cv2
     kernel = np.ones((3,3),np.uint8)
     noDataMask = cv2.dilate(noDataMask.astype(np.uint8),kernel,iterations = 1)
     noDataMask = noDataMask.astype(np.bool)
@@ -349,12 +349,10 @@
 
 
 
-if __name__ == '__main__':
+def main():
     '''
     Main driver.
     '''
-    import numpy as np
-    import time
     
     inps = cmdLineParse()
     
@@ -463,7 +461,6 @@
     SEARCHLIMITX[noDataMask] = 0
     SEARCHLIMITY[noDataMask] = 0
 
-    import scipy.io as sio
     sio.savemat('offset.mat',{'Dx':DX,'Dy':DY,'InterpMask':INTERPMASK,'ChipSizeX':CHIPSIZEX})
 
 #    #####################  Uncomment for debug mode
@@ -555,7 +552,6 @@
                 master_split = str.split(master_filename,'_')
                 slave_split = str.split(slave_filename,'_')
 
-                import netcdf_output as no
                 version = '1.0.5'
                 pair_type = 'radar'
                 detection_method = 'feature'
@@ -568,7 +564,6 @@
                 
 
                 
-                from datetime import date
                 d0 = date(np.int(master_split[5][0:4]),np.int(master_split[5][4:6]),np.int(master_split[5][6:8]))
                 d1 = date(np.int(slave_split[5][0:4]),np.int(slave_split[5][4:6]),np.int(slave_split[5][6:8]))
                 date_dt_base = d1 - d0
@@ -580,9 +575,29 @@
                     date_ct = d0 + (d1 - d0)/2
                     date_center = date_ct.strftime("%Y%m%d")
             
-                IMG_INFO_DICT = {'mission_img1':master_split[0][0],'sensor_img1':'C','satellite_img1':master_split[0][1:3],'acquisition_img1':master_split[5][0:8],'absolute_orbit_number_img1':master_split[7],'mission_data_take_ID_img1':master_split[8],'product_unique_ID_img1':master_split[9][0:4],'mission_img2':slave_split[0][0],'sensor_img2':'C','satellite_img2':slave_split[0][1:3],'acquisition_img2':slave_split[5][0:8],'absolute_orbit_number_img2':slave_split[7],'mission_data_take_ID_img2':slave_split[8],'product_unique_ID_img2':slave_split[9][0:4],'date_dt':date_dt,'date_center':date_center,'roi_valid_percentage':roi_valid_percentage,'autoRIFT_software_version':version}
-
-                no.netCDF_packaging(VX, VY, DX, DY, INTERPMASK, CHIPSIZEX, CHIPSIZEY, rangePixelSize, azimuthPixelSize, dt, epsg, srs, tran, out_nc_filename, pair_type, detection_method, coordinates, IMG_INFO_DICT)
+                IMG_INFO_DICT = {'mission_img1':master_split[0][0],
+                                 'sensor_img1':'C',
+                                 'satellite_img1':master_split[0][1:3],
+                                 'acquisition_img1':master_split[5][0:8],
+                                 'absolute_orbit_number_img1':master_split[7],
+                                 'mission_data_take_ID_img1':master_split[8],
+                                 'product_unique_ID_img1':master_split[9][0:4],
+                                 'mission_img2':slave_split[0][0],
+                                 'sensor_img2':'C',
+                                 'satellite_img2':slave_split[0][1:3],
+                                 'acquisition_img2':slave_split[5][0:8],
+                                 'absolute_orbit_number_img2':slave_split[7],
+                                 'mission_data_take_ID_img2':slave_split[8],
+                                 'product_unique_ID_img2':slave_split[9][0:4],
+                                 'date_dt':date_dt,
+                                 'date_center':date_center,
+                                 'roi_valid_percentage':roi_valid_percentage,
+                                 'autoRIFT_software_version':version}
+
+                no.netCDF_packaging(
+                    VX, VY, DX, DY, INTERPMASK, CHIPSIZEX, CHIPSIZEY, rangePixelSize, azimuthPixelSize,
+                    dt, epsg, srs, tran, out_nc_filename, pair_type, detection_method, coordinates, IMG_INFO_DICT
+                )
 
             elif inps.nc_sensor == "L":
                 
@@ -595,7 +610,6 @@
                 master_split = str.split(master_filename,'_')
                 slave_split = str.split(slave_filename,'_')
                 
-                import netcdf_output as no
                 version = '1.0.5'
                 pair_type = 'optical'
                 detection_method = 'feature'
@@ -606,7 +620,6 @@
                 roi_valid_percentage = np.sum(CHIPSIZEX!=0)/np.sum(SEARCHLIMITX!=0)*100.0
                 CHIPSIZEY = np.round(CHIPSIZEX * ScaleChipSizeY / 2) * 2
 
-                from datetime import date
                 d0 = date(np.int(master_split[3][0:4]),np.int(master_split[3][4:6]),np.int(master_split[3][6:8]))
                 d1 = date(np.int(slave_split[3][0:4]),np.int(slave_split[3][4:6]),np.int(slave_split[3][6:8]))
                 date_dt_base = d1 - d0
@@ -618,9 +631,35 @@
                     date_ct = d0 + (d1 - d0)/2
                     date_center = date_ct.strftime("%Y%m%d")
 
-                IMG_INFO_DICT = {'mission_img1':master_split[0][0],'sensor_img1':master_split[0][1],'satellite_img1':np.float64(master_split[0][2:4]),'correction_level_img1':master_split[1],'path_img1':np.float64(master_split[2][0:3]),'row_img1':np.float64(master_split[2][3:6]),'acquisition_date_img1':master_split[3][0:8],'processing_date_img1':master_split[4][0:8],'collection_number_img1':np.float64(master_split[5]),'collection_category_img1':master_split[6],'mission_img2':slave_split[0][0],'sensor_img2':slave_split[0][1],'satellite_img2':np.float64(slave_split[0][2:4]),'correction_level_img2':slave_split[1],'path_img2':np.float64(slave_split[2][0:3]),'row_img2':np.float64(slave_split[2][3:6]),'acquisition_date_img2':slave_split[3][0:8],'processing_date_img2':slave_split[4][0:8],'collection_number_img2':np.float64(slave_split[5]),'collection_category_img2':slave_split[6],'date_dt':date_dt,'date_center':date_center,'roi_valid_percentage':roi_valid_percentage,'autoRIFT_software_version':version}
+                IMG_INFO_DICT = {'mission_img1':master_split[0][0],
+                                 'sensor_img1':master_split[0][1],
+                                 'satellite_img1':np.float64(master_split[0][2:4]),
+                                 'correction_level_img1':master_split[1],
+                                 'path_img1':np.float64(master_split[2][0:3]),
+                                 'row_img1':np.float64(master_split[2][3:6]),
+                                 'acquisition_date_img1':master_split[3][0:8],
+                                 'processing_date_img1':master_split[4][0:8],
+                                 'collection_number_img1':np.float64(master_split[5]),
+                                 'collection_category_img1':master_split[6],
+                                 'mission_img2':slave_split[0][0],
+                                 'sensor_img2':slave_split[0][1],
+                                 'satellite_img2':np.float64(slave_split[0][2:4]),
+                                 'correction_level_img2':slave_split[1],
+                                 'path_img2':np.float64(slave_split[2][0:3]),
+                                 'row_img2':np.float64(slave_split[2][3:6]),
+                                 'acquisition_date_img2':slave_split[3][0:8],
+                                 'processing_date_img2':slave_split[4][0:8],
+                                 'collection_number_img2':np.float64(slave_split[5]),
+                                 'collection_category_img2':slave_split[6],
+                                 'date_dt':date_dt,
+                                 'date_center':date_center,
+                                 'roi_valid_percentage':roi_valid_percentage,
+                                 'autoRIFT_software_version':version}
                 
-                no.netCDF_packaging(VX, VY, DX, DY, INTERPMASK, CHIPSIZEX, CHIPSIZEY, XPixelSize, YPixelSize, None, epsg, srs, tran, out_nc_filename, pair_type, detection_method, coordinates, IMG_INFO_DICT)
+                no.netCDF_packaging(
+                    VX, VY, DX, DY, INTERPMASK, CHIPSIZEX, CHIPSIZEY, XPixelSize, YPixelSize,
+                    None, epsg, srs, tran, out_nc_filename, pair_type, detection_method, coordinates, IMG_INFO_DICT
+                )
 
             elif inps.nc_sensor is None:
                 print('netCDF packaging not performed')
@@ -630,3 +669,7 @@
 
         print("Write Outputs Done!!!")
         print(time.time()-t1)
+
+
+if __name__ == '__main__':
+    main()
--- testGeogrid_ISCE.orig.py	2020-06-26 08:51:29.390334041 -0800
+++ testGeogrid_ISCE.py	2020-06-26 09:33:55.933819812 -0800
@@ -1,6 +1,11 @@
 #!/usr/bin/env python3
-
-#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+# This is a substantially modified copy of the testGeogrid_ISCE.py script
+# as described in the README.md in this directory. See the LICENSE file in this
+# directory for the original terms and conditions, and CHANGES.diff for a detailed
+# description of the changes. Notice, all changes are released under the terms
+# and conditions of hyp3-autorift's LICENSE.
+# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 # Copyright 2019 California Institute of Technology. ALL RIGHTS RESERVED.
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
@@ -26,14 +31,20 @@
 #
 # Authors: Piyush Agram, Yang Lei
 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+import argparse
+import os
 
+import numpy as np
+from isce.components.contrib.geo_autoRIFT.geogrid import Geogrid
+from isce.components.contrib.geo_autoRIFT.geogrid import GeogridOptical
+from isce.components.isceobj.Orbit.Orbit import Orbit
+from isce.components.iscesys.Component.ProductManager import ProductManager as PM
+from osgeo import gdal
 
 def cmdLineParse():
     '''
     Command line parser.
     '''
-    import argparse
-
     parser = argparse.ArgumentParser(description='Output geo grid')
     parser.add_argument('-m', '--input_m', dest='indir_m', type=str, required=True,
             help='Input folder with ISCE swath files for master image or master image file name (in GeoTIFF format and Cartesian coordinates)')
@@ -78,8 +89,6 @@
     '''
     Load the product using Product Manager.
     '''
-    import isce
-    from iscesys.Component.ProductManager import ProductManager as PM
 
     pm = PM()
     pm.configure()
@@ -90,9 +99,6 @@
 
 
 def getMergedOrbit(product):
-    import isce
-    from isceobj.Orbit.Orbit import Orbit
-
     ###Create merged orbit
     orb = Orbit()
     orb.configure()
@@ -117,8 +123,6 @@
     '''
     Input file.
     '''
-    import os
-    import numpy as np
 
     frames = []
     for swath in range(1,4):
@@ -146,11 +150,6 @@
     '''
         Input file.
         '''
-    import os
-    import numpy as np
-    
-    from osgeo import gdal, osr
-    import struct
     
     DS = gdal.Open(indir, gdal.GA_ReadOnly)
     trans = DS.GetGeoTransform()
@@ -180,10 +179,6 @@
     Wire and run geogrid.
     '''
 
-    import isce
-    from components.contrib.geo_autoRIFT.geogrid import Geogrid
-#     from geogrid import Geogrid
-
     obj = Geogrid()
     obj.configure()
 
@@ -229,7 +224,6 @@
         Wire and run geogrid.
         '''
 
-    from components.contrib.geo_autoRIFT.geogrid import GeogridOptical
 #    from geogrid import GeogridOptical
     
     obj = GeogridOptical()
@@ -270,13 +264,13 @@
 
 
 
-if __name__ == '__main__':
+def main():
     '''
     Main driver.
     '''
 
     inps = cmdLineParse()
-    
+
     if inps.optical_flag == 1:
         metadata_m = loadMetadataOptical(inps.indir_m)
         metadata_s = loadMetadataOptical(inps.indir_s)
@@ -287,4 +281,5 @@
         runGeogrid(metadata_m, metadata_s, inps.demfile, inps.dhdxfile, inps.dhdyfile, inps.vxfile, inps.vyfile, inps.srxfile, inps.sryfile, inps.csminxfile, inps.csminyfile, inps.csmaxxfile, inps.csmaxyfile, inps.ssmfile)
     
 
-
+if __name__ == '__main__':
+    main()

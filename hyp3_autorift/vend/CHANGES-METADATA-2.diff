--- testautoRIFT.py
+++ testautoRIFT.py
@@ -824,26 +824,26 @@ def generateAutoriftProduct(indir_m, indir_s, grid_location, init_offset, search
                     date_center = date_ct.strftime("%Y%m%dT%H:%M:%S.%f").rstrip('0')
 
                     IMG_INFO_DICT = {
-                        'mission_img1': master_split[0][0],
-                        'sensor_img1': 'C',
-                        'satellite_img1': master_split[0][1:3],
-                        'acquisition_date_img1': master_dt,
-                        'time_standard_img1': 'UTC',
                         'absolute_orbit_number_img1': master_split[7],
-                        'mission_data_take_ID_img1': master_split[8],
-                        'product_unique_ID_img1': master_split[9][0:4],
+                        'absolute_orbit_number_img2': slave_split[7],
+                        'acquisition_date_img1': master_dt,
+                        'acquisition_date_img2': slave_dt,
                         'flight_direction_img1': flight_direction_m,
+                        'flight_direction_img2': flight_direction_s,
+                        'mission_data_take_ID_img1': master_split[8],
+                        'mission_data_take_ID_img2': slave_split[8],
+                        'mission_img1': master_split[0][0],
                         'mission_img2': slave_split[0][0],
-                        'sensor_img2': 'C',
+                        'product_unique_ID_img1': master_split[9][0:4],
+                        'product_unique_ID_img2': slave_split[9][0:4],
+                        'satellite_img1': master_split[0][1:3],
                         'satellite_img2': slave_split[0][1:3],
-                        'acquisition_date_img2': slave_dt,
+                        'sensor_img1': 'C',
+                        'sensor_img2': 'C',
+                        'time_standard_img1': 'UTC',
                         'time_standard_img2': 'UTC',
-                        'absolute_orbit_number_img2': slave_split[7],
-                        'mission_data_take_ID_img2': slave_split[8],
-                        'product_unique_ID_img2': slave_split[9][0:4],
-                        'flight_direction_img2': flight_direction_s,
-                        'date_dt': date_dt,
                         'date_center': date_center,
+                        'date_dt': date_dt,
                         'latitude': cen_lat,
                         'longitude': cen_lon,
                         'roi_valid_percentage': PPP,
@@ -924,30 +924,30 @@ def generateAutoriftProduct(indir_m, indir_s, grid_location, init_offset, search
                     slave_dt = d1.strftime("%Y%m%dT%H:%M:%S.%f").rstrip('0')
 
                     IMG_INFO_DICT = {
-                        'mission_img1': master_split[0][0],
-                        'sensor_img1': master_split[0][1],
-                        'satellite_img1': np.float64(master_split[0][2:4]),
-                        'correction_level_img1': master_split[1],
-                        'path_img1': np.float64(master_split[2][0:3]),
-                        'row_img1': np.float64(master_split[2][3:6]),
                         'acquisition_date_img1': master_dt,
-                        'time_standard_img1': 'UTC',
-                        'processing_date_img1': master_split[4][0:8],
-                        'collection_number_img1': np.float64(master_split[5]),
+                        'acquisition_date_img2': slave_dt,
                         'collection_category_img1': master_split[6],
-                        'mission_img2': slave_split[0][0],
-                        'sensor_img2': slave_split[0][1],
-                        'satellite_img2': np.float64(slave_split[0][2:4]),
+                        'collection_category_img2': slave_split[6],
+                        'collection_number_img1': np.float64(master_split[5]),
+                        'collection_number_img2': np.float64(slave_split[5]),
+                        'correction_level_img1': master_split[1],
                         'correction_level_img2': slave_split[1],
+                        'mission_img1': master_split[0][0],
+                        'mission_img2': slave_split[0][0],
+                        'path_img1': np.float64(master_split[2][0:3]),
                         'path_img2': np.float64(slave_split[2][0:3]),
+                        'processing_date_img1': master_split[4][0:8],
+                        'processing_date_img2': slave_split[4][0:8],
+                        'row_img1': np.float64(master_split[2][3:6]),
                         'row_img2': np.float64(slave_split[2][3:6]),
-                        'acquisition_date_img2': slave_dt,
+                        'satellite_img1': np.float64(master_split[0][2:4]),
+                        'satellite_img2': np.float64(slave_split[0][2:4]),
+                        'sensor_img1': master_split[0][1],
+                        'sensor_img2': slave_split[0][1],
+                        'time_standard_img1': 'UTC',
                         'time_standard_img2': 'UTC',
-                        'processing_date_img2': slave_split[4][0:8],
-                        'collection_number_img2': np.float64(slave_split[5]),
-                        'collection_category_img2': slave_split[6],
-                        'date_dt': date_dt,
                         'date_center': date_center,
+                        'date_dt': date_dt,
                         'latitude': cen_lat,
                         'longitude': cen_lon,
                         'roi_valid_percentage': PPP,
@@ -1020,20 +1020,20 @@ def generateAutoriftProduct(indir_m, indir_s, grid_location, init_offset, search
                     slave_dt = d1.strftime("%Y%m%dT%H:%M:%S.%f").rstrip('0')
 
                     IMG_INFO_DICT = {
-                        'mission_img1': master_split[0][-3],
-                        'sensor_img1': 'MSI',
-                        'satellite_img1': master_split[0][-2:],
-                        'correction_level_img1': master_split[4][:3],
                         'acquisition_date_img1': master_dt,
-                        'time_standard_img1': 'UTC',
+                        'acquisition_date_img2': slave_dt,
+                        'correction_level_img1': master_split[4][:3],
+                        'correction_level_img2': slave_split[4][:3],
+                        'mission_img1': master_split[0][-3],
                         'mission_img2': slave_split[0][-3],
-                        'sensor_img2': 'MSI',
+                        'satellite_img1': master_split[0][-2:],
                         'satellite_img2': slave_split[0][-2:],
-                        'correction_level_img2': slave_split[4][:3],
-                        'acquisition_date_img2': slave_dt,
+                        'sensor_img1': 'MSI',
+                        'sensor_img2': 'MSI',
+                        'time_standard_img1': 'UTC',
                         'time_standard_img2': 'UTC',
-                        'date_dt': date_dt,
                         'date_center': date_center,
+                        'date_dt': date_dt,
                         'latitude': cen_lat,
                         'longitude': cen_lon,
                         'roi_valid_percentage': PPP,
--- testautoRIFT_ISCE.py
+++ testautoRIFT_ISCE.py
@@ -829,26 +829,26 @@ def generateAutoriftProduct(indir_m, indir_s, grid_location, init_offset, search
                     date_center = date_ct.strftime("%Y%m%dT%H:%M:%S.%f").rstrip('0')
 
                     IMG_INFO_DICT = {
-                        'mission_img1': master_split[0][0],
-                        'sensor_img1': 'C',
-                        'satellite_img1': master_split[0][1:3],
-                        'acquisition_date_img1': master_dt,
-                        'time_standard_img1': 'UTC',
                         'absolute_orbit_number_img1': master_split[7],
-                        'mission_data_take_ID_img1': master_split[8],
-                        'product_unique_ID_img1': master_split[9][0:4],
+                        'absolute_orbit_number_img2': slave_split[7],
+                        'acquisition_date_img1': master_dt,
+                        'acquisition_date_img2': slave_dt,
                         'flight_direction_img1': flight_direction_m,
+                        'flight_direction_img2': flight_direction_s,
+                        'mission_data_take_ID_img1': master_split[8],
+                        'mission_data_take_ID_img2': slave_split[8],
+                        'mission_img1': master_split[0][0],
                         'mission_img2': slave_split[0][0],
-                        'sensor_img2': 'C',
+                        'product_unique_ID_img1': master_split[9][0:4],
+                        'product_unique_ID_img2': slave_split[9][0:4],
+                        'satellite_img1': master_split[0][1:3],
                         'satellite_img2': slave_split[0][1:3],
-                        'acquisition_date_img2': slave_dt,
+                        'sensor_img1': 'C',
+                        'sensor_img2': 'C',
+                        'time_standard_img1': 'UTC',
                         'time_standard_img2': 'UTC',
-                        'absolute_orbit_number_img2': slave_split[7],
-                        'mission_data_take_ID_img2': slave_split[8],
-                        'product_unique_ID_img2': slave_split[9][0:4],
-                        'flight_direction_img2': flight_direction_s,
-                        'date_dt': date_dt,
                         'date_center': date_center,
+                        'date_dt': date_dt,
                         'latitude': cen_lat,
                         'longitude': cen_lon,
                         'roi_valid_percentage': PPP,
@@ -928,30 +928,30 @@ def generateAutoriftProduct(indir_m, indir_s, grid_location, init_offset, search
                     slave_dt = d1.strftime("%Y%m%dT%H:%M:%S.%f").rstrip('0')
 
                     IMG_INFO_DICT = {
-                        'mission_img1': master_split[0][0],
-                        'sensor_img1': master_split[0][1],
-                        'satellite_img1': np.float64(master_split[0][2:4]),
-                        'correction_level_img1': master_split[1],
-                        'path_img1': np.float64(master_split[2][0:3]),
-                        'row_img1': np.float64(master_split[2][3:6]),
                         'acquisition_date_img1': master_dt,
-                        'time_standard_img1': 'UTC',
-                        'processing_date_img1': master_split[4][0:8],
-                        'collection_number_img1': np.float64(master_split[5]),
+                        'acquisition_date_img2': slave_dt,
                         'collection_category_img1': master_split[6],
-                        'mission_img2': slave_split[0][0],
-                        'sensor_img2': slave_split[0][1],
-                        'satellite_img2': np.float64(slave_split[0][2:4]),
+                        'collection_category_img2': slave_split[6],
+                        'collection_number_img1': np.float64(master_split[5]),
+                        'collection_number_img2': np.float64(slave_split[5]),
+                        'correction_level_img1': master_split[1],
                         'correction_level_img2': slave_split[1],
+                        'mission_img1': master_split[0][0],
+                        'mission_img2': slave_split[0][0],
+                        'path_img1': np.float64(master_split[2][0:3]),
                         'path_img2': np.float64(slave_split[2][0:3]),
+                        'processing_date_img1': master_split[4][0:8],
+                        'processing_date_img2': slave_split[4][0:8],
+                        'row_img1': np.float64(master_split[2][3:6]),
                         'row_img2': np.float64(slave_split[2][3:6]),
-                        'acquisition_date_img2': slave_dt,
+                        'satellite_img1': np.float64(master_split[0][2:4]),
+                        'satellite_img2': np.float64(slave_split[0][2:4]),
+                        'sensor_img1': master_split[0][1],
+                        'sensor_img2': slave_split[0][1],
+                        'time_standard_img1': 'UTC',
                         'time_standard_img2': 'UTC',
-                        'processing_date_img2': slave_split[4][0:8],
-                        'collection_number_img2': np.float64(slave_split[5]),
-                        'collection_category_img2': slave_split[6],
-                        'date_dt': date_dt,
                         'date_center': date_center,
+                        'date_dt': date_dt,
                         'latitude': cen_lat,
                         'longitude': cen_lon,
                         'roi_valid_percentage': PPP,
@@ -1024,20 +1024,20 @@ def generateAutoriftProduct(indir_m, indir_s, grid_location, init_offset, search
                     slave_dt = d1.strftime("%Y%m%dT%H:%M:%S.%f").rstrip('0')
 
                     IMG_INFO_DICT = {
-                        'mission_img1': master_split[0][-3],
-                        'sensor_img1': 'MSI',
-                        'satellite_img1': master_split[0][-2:],
-                        'correction_level_img1': master_split[4][:3],
                         'acquisition_date_img1': master_dt,
-                        'time_standard_img1': 'UTC',
+                        'acquisition_date_img2': slave_dt,
+                        'correction_level_img1': master_split[4][:3],
+                        'correction_level_img2': slave_split[4][:3],
+                        'mission_img1': master_split[0][-3],
                         'mission_img2': slave_split[0][-3],
-                        'sensor_img2': 'MSI',
+                        'satellite_img1': master_split[0][-2:],
                         'satellite_img2': slave_split[0][-2:],
-                        'correction_level_img2': slave_split[4][:3],
-                        'acquisition_date_img2': slave_dt,
+                        'sensor_img1': 'MSI',
+                        'sensor_img2': 'MSI',
+                        'time_standard_img1': 'UTC',
                         'time_standard_img2': 'UTC',
-                        'date_dt': date_dt,
                         'date_center': date_center,
+                        'date_dt': date_dt,
                         'latitude': cen_lat,
                         'longitude': cen_lon,
                         'roi_valid_percentage': PPP,
--- netcdf_output.py
+++ netcdf_output.py
@@ -630,8 +630,8 @@ def netCDF_packaging(VX, VY, DX, DY, INTERPMASK, CHIPSIZEX, CHIPSIZEY, SSM, SSM1
         vx_error = vx_error_slow
     else:
         vx_error = vx_error_mod
-    var.setncattr('vx_error',int(round(vx_error*10))/10)
-    var.setncattr('vx_error_description','best estimate of x_velocity error: vx_error is populated according to the approach used for the velocity bias correction as indicated in "flag_stable_shift"')
+    var.setncattr('error',int(round(vx_error*10))/10)
+    var.setncattr('error_description','best estimate of x_velocity error: vx_error is populated according to the approach used for the velocity bias correction as indicated in "stable_shift_flag"')
 
     if stable_shift_applied == 2:
         var.setncattr('stable_shift',int(round(vx_mean_shift1*10))/10)
@@ -639,8 +639,8 @@ def netCDF_packaging(VX, VY, DX, DY, INTERPMASK, CHIPSIZEX, CHIPSIZEY, SSM, SSM1
         var.setncattr('stable_shift',int(round(vx_mean_shift*10))/10)
     else:
         var.setncattr('stable_shift',np.nan)
-    var.setncattr('flag_stable_shift',stable_shift_applied)
-    var.setncattr('flag_stable_shift_description','flag for applying velocity bias correction: 0 = no correction; 1 = correction from overlapping stable surface mask (stationary or slow-flowing surfaces with velocity < 15 m/yr)(top priority); 2 = correction from slowest 25% of overlapping velocities (second priority)')
+    var.setncattr('stable_shift_flag',stable_shift_applied)
+    var.setncattr('stable_shift_flag_description','flag for applying velocity bias correction: 0 = no correction; 1 = correction from overlapping stable surface mask (stationary or slow-flowing surfaces with velocity < 15 m/yr)(top priority); 2 = correction from slowest 25% of overlapping velocities (second priority)')
 
 
     var.setncattr('stable_count_mask',stable_count)
@@ -655,17 +655,17 @@ def netCDF_packaging(VX, VY, DX, DY, INTERPMASK, CHIPSIZEX, CHIPSIZEY, SSM, SSM1
         var.setncattr('stable_shift_slow',np.nan)
 
     if stable_count != 0:
-        var.setncattr('vx_error_mask',int(round(vx_error_mask*10))/10)
+        var.setncattr('error_mask',int(round(vx_error_mask*10))/10)
     else:
-        var.setncattr('vx_error_mask',np.nan)
-    var.setncattr('vx_error_mask_description','RMSE over stable surfaces, stationary or slow-flowing surfaces with velocity < 15 m/yr identified from an external mask')
+        var.setncattr('error_mask',np.nan)
+    var.setncattr('error_mask_description','RMSE over stable surfaces, stationary or slow-flowing surfaces with velocity < 15 m/yr identified from an external mask')
     if stable_count1 != 0:
-        var.setncattr('vx_error_slow',int(round(vx_error_slow*10))/10)
+        var.setncattr('error_slow',int(round(vx_error_slow*10))/10)
     else:
-        var.setncattr('vx_error_slow',np.nan)
-    var.setncattr('vx_error_slow_description','RMSE over slowest 25% of retrieved velocities')
-    var.setncattr('vx_error_modeled',int(round(vx_error_mod*10))/10)
-    var.setncattr('vx_error_modeled_description','1-sigma error calculated using a modeled error-dt relationship')
+        var.setncattr('error_slow',np.nan)
+    var.setncattr('error_slow_description','RMSE over slowest 25% of retrieved velocities')
+    var.setncattr('error_modeled',int(round(vx_error_mod*10))/10)
+    var.setncattr('error_modeled_description','1-sigma error calculated using a modeled error-dt relationship')
 
     var.setncattr('grid_mapping',mapping_name)
 
@@ -713,8 +713,8 @@ def netCDF_packaging(VX, VY, DX, DY, INTERPMASK, CHIPSIZEX, CHIPSIZEY, SSM, SSM1
         vy_error = vy_error_slow
     else:
         vy_error = vy_error_mod
-    var.setncattr('vy_error',int(round(vy_error*10))/10)
-    var.setncattr('vy_error_description','best estimate of y_velocity error: vy_error is populated according to the approach used for the velocity bias correction as indicated in "flag_stable_shift"')
+    var.setncattr('error',int(round(vy_error*10))/10)
+    var.setncattr('error_description','best estimate of y_velocity error: vy_error is populated according to the approach used for the velocity bias correction as indicated in "stable_shift_flag"')
 
 
     if stable_shift_applied == 2:
@@ -723,8 +723,8 @@ def netCDF_packaging(VX, VY, DX, DY, INTERPMASK, CHIPSIZEX, CHIPSIZEY, SSM, SSM1
         var.setncattr('stable_shift',int(round(vy_mean_shift*10))/10)
     else:
         var.setncattr('stable_shift',np.nan)
-    var.setncattr('flag_stable_shift',stable_shift_applied)
-    var.setncattr('flag_stable_shift_description','flag for applying velocity bias correction: 0 = no correction; 1 = correction from overlapping stable surface mask (stationary or slow-flowing surfaces with velocity < 15 m/yr)(top priority); 2 = correction from slowest 25% of overlapping velocities (second priority)')
+    var.setncattr('stable_shift_flag',stable_shift_applied)
+    var.setncattr('stable_shift_flag_description','flag for applying velocity bias correction: 0 = no correction; 1 = correction from overlapping stable surface mask (stationary or slow-flowing surfaces with velocity < 15 m/yr)(top priority); 2 = correction from slowest 25% of overlapping velocities (second priority)')
 
 
     var.setncattr('stable_count_mask',stable_count)
@@ -739,17 +739,17 @@ def netCDF_packaging(VX, VY, DX, DY, INTERPMASK, CHIPSIZEX, CHIPSIZEY, SSM, SSM1
         var.setncattr('stable_shift_slow',np.nan)
 
     if stable_count != 0:
-        var.setncattr('vy_error_mask',int(round(vy_error_mask*10))/10)
+        var.setncattr('error_mask',int(round(vy_error_mask*10))/10)
     else:
-        var.setncattr('vy_error_mask',np.nan)
-    var.setncattr('vy_error_mask_description','RMSE over stable surfaces, stationary or slow-flowing surfaces with velocity < 15 m/yr identified from an external mask')
+        var.setncattr('error_mask',np.nan)
+    var.setncattr('error_mask_description','RMSE over stable surfaces, stationary or slow-flowing surfaces with velocity < 15 m/yr identified from an external mask')
     if stable_count1 != 0:
-        var.setncattr('vy_error_slow',int(round(vy_error_slow*10))/10)
+        var.setncattr('error_slow',int(round(vy_error_slow*10))/10)
     else:
-        var.setncattr('vy_error_slow',np.nan)
-    var.setncattr('vy_error_slow_description','RMSE over slowest 25% of retrieved velocities')
-    var.setncattr('vy_error_modeled',int(round(vy_error_mod*10))/10)
-    var.setncattr('vy_error_modeled_description','1-sigma error calculated using a modeled error-dt relationship')
+        var.setncattr('error_slow',np.nan)
+    var.setncattr('error_slow_description','RMSE over slowest 25% of retrieved velocities')
+    var.setncattr('error_modeled',int(round(vy_error_mod*10))/10)
+    var.setncattr('error_modeled_description','1-sigma error calculated using a modeled error-dt relationship')
 
 
     var.setncattr('grid_mapping',mapping_name)
@@ -841,8 +841,8 @@ def netCDF_packaging(VX, VY, DX, DY, INTERPMASK, CHIPSIZEX, CHIPSIZEY, SSM, SSM1
             vr_error = vr_error_slow
         else:
             vr_error = vr_error_mod
-        var.setncattr('vr_error',int(round(vr_error*10))/10)
-        var.setncattr('vr_error_description','best estimate of range_velocity error: vr_error is populated according to the approach used for the velocity bias correction as indicated in "flag_stable_shift"')
+        var.setncattr('error',int(round(vr_error*10))/10)
+        var.setncattr('error_description','best estimate of range_velocity error: vr_error is populated according to the approach used for the velocity bias correction as indicated in "stable_shift_flag"')
 
 
         if stable_shift_applied == 2:
@@ -851,8 +851,8 @@ def netCDF_packaging(VX, VY, DX, DY, INTERPMASK, CHIPSIZEX, CHIPSIZEY, SSM, SSM1
             var.setncattr('stable_shift',int(round(vr_mean_shift*10))/10)
         else:
             var.setncattr('stable_shift',np.nan)
-        var.setncattr('flag_stable_shift',stable_shift_applied)
-        var.setncattr('flag_stable_shift_description','flag for applying velocity bias correction: 0 = no correction; 1 = correction from overlapping stable surface mask (stationary or slow-flowing surfaces with velocity < 15 m/yr)(top priority); 2 = correction from slowest 25% of overlapping velocities (second priority)')
+        var.setncattr('stable_shift_flag',stable_shift_applied)
+        var.setncattr('stable_shift_flag_description','flag for applying velocity bias correction: 0 = no correction; 1 = correction from overlapping stable surface mask (stationary or slow-flowing surfaces with velocity < 15 m/yr)(top priority); 2 = correction from slowest 25% of overlapping velocities (second priority)')
 
 
         var.setncattr('stable_count_mask',stable_count)
@@ -867,17 +867,17 @@ def netCDF_packaging(VX, VY, DX, DY, INTERPMASK, CHIPSIZEX, CHIPSIZEY, SSM, SSM1
             var.setncattr('stable_shift_slow',np.nan)
 
         if stable_count != 0:
-            var.setncattr('vr_error_mask',int(round(vr_error_mask*10))/10)
+            var.setncattr('error_mask',int(round(vr_error_mask*10))/10)
         else:
-            var.setncattr('vr_error_mask',np.nan)
-        var.setncattr('vr_error_mask_description','RMSE over stable surfaces, stationary or slow-flowing surfaces with velocity < 15 m/yr identified from an external mask')
+            var.setncattr('error_mask',np.nan)
+        var.setncattr('error_mask_description','RMSE over stable surfaces, stationary or slow-flowing surfaces with velocity < 15 m/yr identified from an external mask')
         if stable_count1 != 0:
-            var.setncattr('vr_error_slow',int(round(vr_error_slow*10))/10)
+            var.setncattr('error_slow',int(round(vr_error_slow*10))/10)
         else:
-            var.setncattr('vr_error_slow',np.nan)
-        var.setncattr('vr_error_slow_description','RMSE over slowest 25% of retrieved velocities')
-        var.setncattr('vr_error_modeled',int(round(vr_error_mod*10))/10)
-        var.setncattr('vr_error_modeled_description','1-sigma error calculated using a modeled error-dt relationship')
+            var.setncattr('error_slow',np.nan)
+        var.setncattr('error_slow_description','RMSE over slowest 25% of retrieved velocities')
+        var.setncattr('error_modeled',int(round(vr_error_mod*10))/10)
+        var.setncattr('error_modeled_description','1-sigma error calculated using a modeled error-dt relationship')
 
 
         var.setncattr('grid_mapping',mapping_name)
@@ -921,8 +921,8 @@ def netCDF_packaging(VX, VY, DX, DY, INTERPMASK, CHIPSIZEX, CHIPSIZEY, SSM, SSM1
             va_error = va_error_slow
         else:
             va_error = va_error_mod
-        var.setncattr('va_error',int(round(va_error*10))/10)
-        var.setncattr('va_error_description','best estimate of azimuth_velocity error: va_error is populated according to the approach used for the velocity bias correction as indicated in "flag_stable_shift"')
+        var.setncattr('error',int(round(va_error*10))/10)
+        var.setncattr('error_description','best estimate of azimuth_velocity error: va_error is populated according to the approach used for the velocity bias correction as indicated in "stable_shift_flag"')
 
 
         if stable_shift_applied == 2:
@@ -931,8 +931,8 @@ def netCDF_packaging(VX, VY, DX, DY, INTERPMASK, CHIPSIZEX, CHIPSIZEY, SSM, SSM1
             var.setncattr('stable_shift',int(round(va_mean_shift*10))/10)
         else:
             var.setncattr('stable_shift',np.nan)
-        var.setncattr('flag_stable_shift',stable_shift_applied)
-        var.setncattr('flag_stable_shift_description','flag for applying velocity bias correction: 0 = no correction; 1 = correction from overlapping stable surface mask (stationary or slow-flowing surfaces with velocity < 15 m/yr)(top priority); 2 = correction from slowest 25% of overlapping velocities (second priority)')
+        var.setncattr('stable_shift_flag',stable_shift_applied)
+        var.setncattr('stable_shift_flag_description','flag for applying velocity bias correction: 0 = no correction; 1 = correction from overlapping stable surface mask (stationary or slow-flowing surfaces with velocity < 15 m/yr)(top priority); 2 = correction from slowest 25% of overlapping velocities (second priority)')
 
 
         var.setncattr('stable_count_mask',stable_count)
@@ -947,17 +947,17 @@ def netCDF_packaging(VX, VY, DX, DY, INTERPMASK, CHIPSIZEX, CHIPSIZEY, SSM, SSM1
             var.setncattr('stable_shift_slow',np.nan)
 
         if stable_count != 0:
-            var.setncattr('va_error_mask',int(round(va_error_mask*10))/10)
+            var.setncattr('error_mask',int(round(va_error_mask*10))/10)
         else:
-            var.setncattr('va_error_mask',np.nan)
-        var.setncattr('va_error_mask_description','RMSE over stable surfaces, stationary or slow-flowing surfaces with velocity < 15 m/yr identified from an external mask')
+            var.setncattr('error_mask',np.nan)
+        var.setncattr('error_mask_description','RMSE over stable surfaces, stationary or slow-flowing surfaces with velocity < 15 m/yr identified from an external mask')
         if stable_count1 != 0:
-            var.setncattr('va_error_slow',int(round(va_error_slow*10))/10)
+            var.setncattr('error_slow',int(round(va_error_slow*10))/10)
         else:
-            var.setncattr('va_error_slow',np.nan)
-        var.setncattr('va_error_slow_description','RMSE over slowest 25% of retrieved velocities')
-        var.setncattr('va_error_modeled',int(round(va_error_mod*10))/10)
-        var.setncattr('va_error_modeled_description','1-sigma error calculated using a modeled error-dt relationship')
+            var.setncattr('error_slow',np.nan)
+        var.setncattr('error_slow_description','RMSE over slowest 25% of retrieved velocities')
+        var.setncattr('error_modeled',int(round(va_error_mod*10))/10)
+        var.setncattr('error_modeled_description','1-sigma error calculated using a modeled error-dt relationship')
 
 
         var.setncattr('grid_mapping',mapping_name)
@@ -1094,8 +1094,8 @@ def netCDF_packaging(VX, VY, DX, DY, INTERPMASK, CHIPSIZEX, CHIPSIZEY, SSM, SSM1
 #            vxp_error = vxp_error_slow
 #        else:
 #            vxp_error = vxp_error_mod
-#        var.setncattr('vxp_error',int(round(vxp_error*10))/10)
-#        var.setncattr('vxp_error_description','best estimate of projected_x_velocity error: vxp_error is populated according to the approach used for the velocity bias correction as indicated in "flag_stable_shift"')
+#        var.setncattr('error',int(round(vxp_error*10))/10)
+#        var.setncattr('error_description','best estimate of projected_x_velocity error: vxp_error is populated according to the approach used for the velocity bias correction as indicated in "stable_shift_flag"')
 #
 #
 #        if stable_shift_applied_p == 2:
@@ -1104,8 +1104,8 @@ def netCDF_packaging(VX, VY, DX, DY, INTERPMASK, CHIPSIZEX, CHIPSIZEY, SSM, SSM1
 #            var.setncattr('stable_shift',int(round(vxp_mean_shift*10))/10)
 #        else:
 #            var.setncattr('stable_shift',np.nan)
-#        var.setncattr('flag_stable_shift',stable_shift_applied_p)
-#        var.setncattr('flag_stable_shift_description','flag for applying velocity bias correction: 0 = no correction; 1 = correction from overlapping stable surface mask (stationary or slow-flowing surfaces with velocity < 15 m/yr)(top priority); 2 = correction from slowest 25% of overlapping velocities (second priority)')
+#        var.setncattr('stable_shift_flag',stable_shift_applied_p)
+#        var.setncattr('stable_shift_flag_description','flag for applying velocity bias correction: 0 = no correction; 1 = correction from overlapping stable surface mask (stationary or slow-flowing surfaces with velocity < 15 m/yr)(top priority); 2 = correction from slowest 25% of overlapping velocities (second priority)')
 #
 #
 #        var.setncattr('stable_count_mask',stable_count_p)
@@ -1120,17 +1120,17 @@ def netCDF_packaging(VX, VY, DX, DY, INTERPMASK, CHIPSIZEX, CHIPSIZEY, SSM, SSM1
 #            var.setncattr('stable_shift_slow',np.nan)
 #
 #        if stable_count_p != 0:
-#            var.setncattr('vxp_error_mask',int(round(vxp_error_mask*10))/10)
+#            var.setncattr('error_mask',int(round(vxp_error_mask*10))/10)
 #        else:
-#            var.setncattr('vxp_error_mask',np.nan)
+#            var.setncattr('error_mask',np.nan)
 #        var.setncattr('vxp_error_mask_description','RMSE over stable surfaces, stationary or slow-flowing surfaces with velocity < 15 m/yr identified from an external mask')
 #        if stable_count1_p != 0:
-#            var.setncattr('vxp_error_slow',int(round(vxp_error_slow*10))/10)
+#            var.setncattr('error_slow',int(round(vxp_error_slow*10))/10)
 #        else:
-#            var.setncattr('vxp_error_slow',np.nan)
-#        var.setncattr('vxp_error_slow_description','RMSE over slowest 25% of retrieved velocities')
-#        var.setncattr('vxp_error_modeled',int(round(vxp_error_mod*10))/10)
-#        var.setncattr('vxp_error_modeled_description','1-sigma error calculated using a modeled error-dt relationship')
+#            var.setncattr('error_slow',np.nan)
+#        var.setncattr('error_slow_description','RMSE over slowest 25% of retrieved velocities')
+#        var.setncattr('error_modeled',int(round(vxp_error_mod*10))/10)
+#        var.setncattr('error_modeled_description','1-sigma error calculated using a modeled error-dt relationship')
 #
 #
 #        var.setncattr('grid_mapping',mapping_name)
@@ -1176,8 +1176,8 @@ def netCDF_packaging(VX, VY, DX, DY, INTERPMASK, CHIPSIZEX, CHIPSIZEY, SSM, SSM1
 #            vyp_error = vyp_error_slow
 #        else:
 #            vyp_error = vyp_error_mod
-#        var.setncattr('vyp_error',int(round(vyp_error*10))/10)
-#        var.setncattr('vyp_error_description','best estimate of projected_y_velocity error: vyp_error is populated according to the approach used for the velocity bias correction as indicated in "flag_stable_shift"')
+#        var.setncattr('error',int(round(vyp_error*10))/10)
+#        var.setncattr('error_description','best estimate of projected_y_velocity error: vyp_error is populated according to the approach used for the velocity bias correction as indicated in "stable_shift_flag"')
 #
 #
 #        if stable_shift_applied_p == 2:
@@ -1186,8 +1186,8 @@ def netCDF_packaging(VX, VY, DX, DY, INTERPMASK, CHIPSIZEX, CHIPSIZEY, SSM, SSM1
 #            var.setncattr('stable_shift',int(round(vyp_mean_shift*10))/10)
 #        else:
 #            var.setncattr('stable_shift',np.nan)
-#        var.setncattr('flag_stable_shift',stable_shift_applied_p)
-#        var.setncattr('flag_stable_shift_description','flag for applying velocity bias correction: 0 = no correction; 1 = correction from overlapping stable surface mask (stationary or slow-flowing surfaces with velocity < 15 m/yr)(top priority); 2 = correction from slowest 25% of overlapping velocities (second priority)')
+#        var.setncattr('stable_shift_flag',stable_shift_applied_p)
+#        var.setncattr('stable_shift_flag_description','flag for applying velocity bias correction: 0 = no correction; 1 = correction from overlapping stable surface mask (stationary or slow-flowing surfaces with velocity < 15 m/yr)(top priority); 2 = correction from slowest 25% of overlapping velocities (second priority)')
 #
 #
 #        var.setncattr('stable_count_mask',stable_count_p)
@@ -1202,17 +1202,17 @@ def netCDF_packaging(VX, VY, DX, DY, INTERPMASK, CHIPSIZEX, CHIPSIZEY, SSM, SSM1
 #            var.setncattr('stable_shift_slow',np.nan)
 #
 #        if stable_count_p != 0:
-#            var.setncattr('vyp_error_mask',int(round(vyp_error_mask*10))/10)
+#            var.setncattr('error_mask',int(round(vyp_error_mask*10))/10)
 #        else:
-#            var.setncattr('vyp_error_mask',np.nan)
-#        var.setncattr('vyp_error_mask_description','RMSE over stable surfaces, stationary or slow-flowing surfaces with velocity < 15 m/yr identified from an external mask')
+#            var.setncattr('error_mask',np.nan)
+#        var.setncattr('error_mask_description','RMSE over stable surfaces, stationary or slow-flowing surfaces with velocity < 15 m/yr identified from an external mask')
 #        if stable_count1_p != 0:
-#            var.setncattr('vyp_error_slow',int(round(vyp_error_slow*10))/10)
+#            var.setncattr('error_slow',int(round(vyp_error_slow*10))/10)
 #        else:
-#            var.setncattr('vyp_error_slow',np.nan)
-#        var.setncattr('vyp_error_slow_description','RMSE over slowest 25% of retrieved velocities')
-#        var.setncattr('vyp_error_modeled',int(round(vyp_error_mod*10))/10)
-#        var.setncattr('vyp_error_modeled_description','1-sigma error calculated using a modeled error-dt relationship')
+#            var.setncattr('error_slow',np.nan)
+#        var.setncattr('error_slow_description','RMSE over slowest 25% of retrieved velocities')
+#        var.setncattr('error_modeled',int(round(vyp_error_mod*10))/10)
+#        var.setncattr('error_modeled_description','1-sigma error calculated using a modeled error-dt relationship')
 #
 #
 #        var.setncattr('grid_mapping',mapping_name)
